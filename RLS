(require (planet schematics/random:1:0/random))
;=====Сигномдальная функция(сжимающая функция)====================================================================

(define (pow e x)
  (if (null? x) 0
      (* e (* e (- x 1)))))

(define (F  x)
  (- (/ 1(+ 1 (pow 2.71 x))) 0.5))

;========================гипперболический тангенс===================================================================

(define (TH  x)
  (- (/ (- 1 (pow 2.71 x)) (+ 1 (pow 2.71 x))) 0.5))

;====================================================================================================================
;=====Создаем входной слой===========================================================================================
;====================================================================================================================
;inputs signals
(define x1 (list '(0.5 0.5 1 0.5)
                 '(0.5 1 1 0.5)
                 '(1 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)
                 '(0.5 1 1 0.5)))
;hidden
(define w1 (list '(0 0 0 0)
                 '(0 0 0 1)
                 '(0 0 1 0)
                 '(0 0 1 1)
                 '(0 1 0 0)
                 '(0 1 0 1)
                 '(0 1 1 0)
                 '(0 1 1 1)
                 '(1 0 0 0)
                 '(1 0 0 1)))
;сделать через random, увеличить число слоев!!!!
(define   W '(0 0 0 1))
;====================================================================================================================
(define (mul-list x1 w1 return)
  (cond ((or (null? x1) (null? w1)) return)
        (else (mul-list (cdr x1) (cdr w1) (append return (list (* (car x1) (car w1))))))))

;====================================================================================================================
(define (MUL-LIST lst val return)
  (cond ((null? lst) return)
        (else (MUL-LIST (cdr lst) val (append return (list (* val (car lst))))))))

;====================================================================================================================
(define (MUL-2-LIST lst val return)
  (cond ((null? lst) return)
        (else (MUL-2-LIST (cdr lst) val (append return (list (MUL-LIST (car lst) val '())))))))

;====================================================================================================================
(define (div-list lst1 lst2 return)
  (cond ((and (null? lst1) (null? lst2)) return)
        (else (div-list (cdr lst1) (cdr lst2) (append return (list (/ (car lst1) (car lst2))))))))
;====================================================================================================================
(define (div-2-list lst1 lst2 return)
  (cond ((and (null? lst1) (null? lst2)) return)
        (else (div-2-list (cdr lst1) (cdr lst2) (append return (list (div-list (car lst1) (car lst2) '())))))))

;====================================================================================================================
(define (sum-list lst1 lst2 return)
  (cond ((and (null? lst1) (null? lst2)) return)
        (else (sum-list (cdr lst1) (cdr lst2) (append return (list (+ (car lst1) (car lst2))))))))

;====================================================================================================================
(define (sum-list-N-list lst lst2 return)
  (cond ((null? lst2) return)
        (else (sum-list-N-list lst (cdr lst2) (append return (list (sum-list lst (car lst2) '())))))))

;====================================================================================================================
(define (sum func return)
  (cond ((null? func) return)
        (else (sum (cdr func) (+ return (car func))))))

;====================================================================================================================
(define (A x w return)
  (cond ((or (null? x) (null? w)) return)
     (else (A (cdr x) (cdr w) (append return (list   (F (sum (mul-list (car x) (car w) '()) 0))))))))
(define A1 (A x1 w1 '()))

;====================================================================================================================
;;=====output value==================================================================================================
;====================================================================================================================
(define OUTPUTS  (F  (sum (mul-list A1  W '()) 0)));проход вперед

;====================================================================================================================

;====================================================================================================================
;==========================Algorithm RLS for learning neuron nets====================================================
;====================================================================================================================
(define (iter count)
  (cond ((= count 0) (display "end of line"))
        (else (begin
                (let* ((Target (random 9))
                       (Lambda 0.5)
                       (teta 0.6)
                       (Fproiz (* OUTPUTS (- 1 OUTPUTS)))
                       (Tar (- Target OUTPUTS))
                       (ML (MUL-LIST W Fproiz '()))
                       (Pn-1 (* (- 1 Fproiz) teta))
                       (epsilon (sum (MUL-LIST ML Tar '()) 0))
                       (AA (MUL-2-LIST  x1 (* Fproiz Pn-1) '()))
                       (Pi (* Lambda Pn-1))
                       (Gi (div-2-list  AA (MUL-2-LIST x1 (* (+ Lambda (pow Fproiz 2)) Pi) '()) '())) 
                       (BB (MUL-2-LIST Gi epsilon '()))
                       (Wnout (sum-list-N-list W BB '())))                      
                  (display Wnout)
                  (newline)
                  (iter (- count 1)))))))
(iter 1000)
;====================================================================================================================